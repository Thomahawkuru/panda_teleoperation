/* 
 * This message is auto generated by ROS#. Please DO NOT modify.
 * Note:
 * - Comments from the original code will be written in their own line 
 * - Variable sized arrays will be initialized to array of size 0 
 * Please report any issues at 
 * <https://github.com/siemens/ros-sharp> 
 */



using RosSharp.RosBridgeClient.MessageTypes.Std;
using RosSharp.RosBridgeClient.MessageTypes.Franka;

namespace RosSharp.RosBridgeClient.MessageTypes.FrankaCore
{
    public class RobotState : Message
    {
        public const string RosMessageName = "franka_core_msgs/RobotState";

        public Header header { get; set; }
        public double[] cartesian_collision { get; set; }
        public double[] cartesian_contact { get; set; }
        public double[] O_dP_EE { get; set; }
        //  EE vel computed as J*dq
        //  float64[7] q # joint position, velocity, and effort in joint_states topic
        //  float64[7] dq
        public double[] q_d { get; set; }
        public double[] dq_d { get; set; }
        //  float64[7] tau_J
        public double[] dtau_J { get; set; }
        //  torque derivative
        public double[] tau_J_d { get; set; }
        //  desired joint torque
        //  float64[6] K_F_ext_hat_K
        //  float64[2] elbow
        //  float64[2] elbow_d
        public double[] joint_collision { get; set; }
        public double[] joint_contact { get; set; }
        //  float64[6] O_F_ext_hat_K # in tip state
        public double[] tau_ext_hat_filtered { get; set; }
        //  filtered external torque
        public double[] F_x_Cee { get; set; }
        //  Configured center of mass of the end effector load with respect to flange frame.
        public double[] F_x_Cload { get; set; }
        //  Configured center of mass of the external load with respect to flange frame.
        public double[] F_x_Ctotal { get; set; }
        //  Combined center of mass of the end effector load and the external load with respect to flange frame.
        public double[] I_ee { get; set; }
        //  Configured rotational inertia matrix of the end effector load with respect to center of mass.
        public double[] I_load { get; set; }
        public double[] I_total { get; set; }
        public double m_ee { get; set; }
        //  configured mass of end-effector
        public double m_load { get; set; }
        //  configured mass of external load
        public double m_total { get; set; }
        public double[] gravity { get; set; }
        public double[] coriolis { get; set; }
        public double[] mass_matrix { get; set; }
        //  mass matrix of end-effector wrt base frame # Vectorized 7x7, column-major
        public double[] O_Jac_EE { get; set; }
        //  zero jacobian of end-effector frame. Vectorized 6x7 Jacobian, column-major
        //  float64[16] O_T_EE # ----- moved to endpointstate msg # Vectorized 4x4, column-major
        public double[] O_T_EE_d { get; set; }
        //  Last desired end effector pose of motion generation in base frame.  # Vectorized 4x4, column-major
        public double[] F_T_EE { get; set; }
        //  End effector frame pose in flange frame # Vectorized 4x4, column-major
        public double[] F_T_NE { get; set; }
        //  Nominal End effector frame pose in flange frame (fixed in Desk) # Vectorized 4x4, column-major
        public double[] NE_T_EE { get; set; }
        //  End effector frame pose in Nominal End effector frame # Vectorized 4x4, column-major
        public double[] EE_T_K { get; set; }
        //  Stiffness frame pose in end effector frame # Vectorized 4x4, column-major
        public double time { get; set; }
        public const byte ROBOT_MODE_OTHER = 0;
        public const byte ROBOT_MODE_IDLE = 1;
        public const byte ROBOT_MODE_MOVE = 2;
        public const byte ROBOT_MODE_GUIDING = 3;
        public const byte ROBOT_MODE_REFLEX = 4;
        public const byte ROBOT_MODE_USER_STOPPED = 5;
        public const byte ROBOT_MODE_AUTOMATIC_ERROR_RECOVERY = 6;
        public byte robot_mode { get; set; }
        public Errors current_errors { get; set; }
        public Errors last_motion_errors { get; set; }

        public RobotState()
        {
            this.header = new Header();
            this.cartesian_collision = new double[6];
            this.cartesian_contact = new double[6];
            this.O_dP_EE = new double[6];
            this.q_d = new double[7];
            this.dq_d = new double[7];
            this.dtau_J = new double[7];
            this.tau_J_d = new double[7];
            this.joint_collision = new double[7];
            this.joint_contact = new double[7];
            this.tau_ext_hat_filtered = new double[7];
            this.F_x_Cee = new double[3];
            this.F_x_Cload = new double[3];
            this.F_x_Ctotal = new double[3];
            this.I_ee = new double[9];
            this.I_load = new double[9];
            this.I_total = new double[9];
            this.m_ee = 0.0;
            this.m_load = 0.0;
            this.m_total = 0.0;
            this.gravity = new double[7];
            this.coriolis = new double[7];
            this.mass_matrix = new double[49];
            this.O_Jac_EE = new double[42];
            this.O_T_EE_d = new double[16];
            this.F_T_EE = new double[16];
            this.F_T_NE = new double[16];
            this.NE_T_EE = new double[16];
            this.EE_T_K = new double[16];
            this.time = 0.0;
            this.robot_mode = 0;
            this.current_errors = new Errors();
            this.last_motion_errors = new Errors();
        }

        public RobotState(Header header, double[] cartesian_collision, double[] cartesian_contact, double[] O_dP_EE, double[] q_d, double[] dq_d, double[] dtau_J, double[] tau_J_d, double[] joint_collision, double[] joint_contact, double[] tau_ext_hat_filtered, double[] F_x_Cee, double[] F_x_Cload, double[] F_x_Ctotal, double[] I_ee, double[] I_load, double[] I_total, double m_ee, double m_load, double m_total, double[] gravity, double[] coriolis, double[] mass_matrix, double[] O_Jac_EE, double[] O_T_EE_d, double[] F_T_EE, double[] F_T_NE, double[] NE_T_EE, double[] EE_T_K, double time, byte robot_mode, Errors current_errors, Errors last_motion_errors)
        {
            this.header = header;
            this.cartesian_collision = cartesian_collision;
            this.cartesian_contact = cartesian_contact;
            this.O_dP_EE = O_dP_EE;
            this.q_d = q_d;
            this.dq_d = dq_d;
            this.dtau_J = dtau_J;
            this.tau_J_d = tau_J_d;
            this.joint_collision = joint_collision;
            this.joint_contact = joint_contact;
            this.tau_ext_hat_filtered = tau_ext_hat_filtered;
            this.F_x_Cee = F_x_Cee;
            this.F_x_Cload = F_x_Cload;
            this.F_x_Ctotal = F_x_Ctotal;
            this.I_ee = I_ee;
            this.I_load = I_load;
            this.I_total = I_total;
            this.m_ee = m_ee;
            this.m_load = m_load;
            this.m_total = m_total;
            this.gravity = gravity;
            this.coriolis = coriolis;
            this.mass_matrix = mass_matrix;
            this.O_Jac_EE = O_Jac_EE;
            this.O_T_EE_d = O_T_EE_d;
            this.F_T_EE = F_T_EE;
            this.F_T_NE = F_T_NE;
            this.NE_T_EE = NE_T_EE;
            this.EE_T_K = EE_T_K;
            this.time = time;
            this.robot_mode = robot_mode;
            this.current_errors = current_errors;
            this.last_motion_errors = last_motion_errors;
        }
    }
}
